bundle agent vcs_freshclone(prefix)
{
  vars:
    use_git::
      "vcs_clone" slist => {
                             "/usr/bin/git clean -f -f -x -q -d ."
                           };
      "vcs_configfile" string => "$($(prefix)path).git/config";

  classes:
      # test if the last component of the "vcs" path arg matches a known VCS
      "use_git" expression => strcmp(lastnode("$($(prefix)vcs)","/"), "git");

      "$(param_keys)_gitconfig_exists" expression => fileexists("$($(params)[$(param_keys)][path])/.git/config");

      # TODO make sure if it exists the git config contains the correct information
      #files:
      #    # if the git config exists, make sure it has the proper settings for origin and master
      #    "$($(params)[$(param_keys)][path])/.git/config"
      #        edit_line => 

  commands:

      # We only need to perform cleanup operations if we did not do a fresh new clone
      "/usr/bin/git clean -f -f -x -q -d ."
      handle     => "git_freshclone_commands_remove_untracked",
      contain    => in_dir("$($(prefix)path)"),
      ifvarclass => "$(param_keys)_gitconfig_exists.!git_freshclone_new_clone_$(param_keys)",
      comment    => "Cleanup - Remove untracked files";

      "/usr/bin/git reset -q --hard HEAD"
      handle     => "git_freshclone_commands_discard_changes",
      contain    => in_dir("$($(params)[$(param_keys)][path])"),
      ifvarclass => "$(param_keys)_gitconfig_exists.!git_freshclone_new_clone_$(param_keys)",
      comment    => "Cleanup - Discard any changes to index and working tree since HEAD";

      "/usr/bin/git checkout $($(params)[$(param_keys)][branch])"
      handle     => "git_freshclone_commands_checkout_branch",
      contain    => in_dir("$($(params)[$(param_keys)][path])"),
      ifvarclass => "$(param_keys)_gitconfig_exists.!git_freshclone_new_clone_$(param_keys)",
      comment    => "Cleanup - Make sure we have the proper branch checked out";

      "/usr/bin/git pull -q -s recursive -Xtheirs origin $($(params)[$(param_keys)][branch])"
      handle     => "git_freshclone_commands_pull_changes",
      contain    => in_dir("$($(params)[$(param_keys)][path])"),
      ifvarclass => "$(param_keys)_gitconfig_exists.!git_freshclone_new_clone_$(param_keys)",
      comment    => "Update - Make sure we have the latest changes from origin";

      "/usr/bin/git reset -q --hard HEAD"
      handle     => "git_freshclone_commands_reset_to_latest_updates",
      contain    => in_dir("$($(params)[$(param_keys)][path])"),
      ifvarclass => "$(param_keys)_gitconfig_exists.!git_freshclone_new_clone_$(param_keys)",
      comment    => "Update - Make sure we have reset the working tree to the latest updates";

      # This does not handle what to do if your trying to checkout to a non empty directory
      # TODO: provide _force paramater to allow obliterating the directory if its not empty and not a checkout
      "/usr/bin/git clone $($(params)[$(param_keys)][origin]) $($(params)[$(param_keys)][path])"
      handle     => "git_freshclone_commands_git_clone",
      ifvarclass => "!$(param_keys)_gitconfig_exists",
      classes    => if_ok("git_freshclone_new_clone_$(param_keys)"),
      comment    => "Since no git repository  exists create a new clone";

  reports:
    cfengine::
      # report if the git config exists, but not if we performed a new clone
      "$($(params)[$(param_keys)][path])/.git/config exists",
      ifvarclass => "$(param_keys)_gitconfig_exists.!git_freshclone_new_clone_$(param_keys)";

      "New clone for $(params) created at $($(params)[$(param_keys)][path]) from $($(params)[$(param_keys)][origin])",
      ifvarclass => canonify("git_freshclone_new_clone_$(param_keys)");

}

bundle agent meta_vcs_freshclone
{
  vars:
      # acceptable values: "/usr/bin/git" for example
      "optional_argument[vcs]" string => "string";

      "argument[path]"   string => "string";
      "argument[origin]" string => "string";
      "argument[branch]" string => "string";

      "default[vcs]"     string => "/usr/bin/git";
}
