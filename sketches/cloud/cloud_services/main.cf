bundle agent cloud_services(prefix)
{
  classes:

  vars:
      "canon_prefix" string => canonify("$(prefix)");
      "contexts"     slist  => getindices("$(prefix)bycontext");

  methods:
      # this is freakin' awesome
      "params" usebundle => cloud_context("$(prefix)", "$(contexts)"),
      classes => always("$(canon_prefix)prepared"),
      ifvarclass => "$(contexts)";

  services:
      "$(cloud_context.count) $(cloud_context.class)"
      service_policy => "$(cloud_context.state)",
      service_method => cloud_services_handler,
      ifvarclass => "$(canon_prefix)prepared";

  reports:
    verbose::
      "Invoking cloud_services: $(cloud_context.count) $(cloud_context.class)"
      ifvarclass => "$(canon_prefix)prepared";

      "Not invoking cloud_services, no match for context $(contexts)"
      ifvarclass => "!$(canon_prefix)prepared";
}

bundle agent meta_cloud_services
{
  vars:
      # look in params/demo.json to see how we fill in the needed services
      "argument[install_cfengine]" string => "context";
      "argument[ec2]"              string => "array";
      "argument[vcli]"             string => "array";
      "argument[bycontext]"        string => "array";

}

bundle agent cloud_context(prefix, context)
{
  vars:
      "active_context" string => "$(context)";
      "active_prefix" string => "$(prefix)";

      "stype" string => "$($(prefix)bycontext[$(context)][stype])",
      comment => "Service type in context $(context)",
      handle => "cloud_context_$(prefix)_stype";

      "count" string => "$($(prefix)bycontext[$(context)][count])",
      comment => "Desired service instance count in context $(context)",
      handle => "cloud_context_$(prefix)_count";

      "class" string => "$($(prefix)bycontext[$(context)][class])",
      comment => "Service instance class in context $(context)",
      handle => "cloud_context_$(prefix)_class";

      "state" string => "$($(prefix)bycontext[$(context)][state])",
      comment => "Whether service is to be 'start'ed or 'stop'ped in context $(context)",
      handle => "cloud_context_$(prefix)_state";

      "disable_ssl_verify" string => "$($(prefix)bycontext[$(context)][disable_ssl_verify])",
      comment => "Whether the SSL verification should be disabled in context $(context)",
      handle => "cloud_context_$(prefix)_disable_ssl_verify";

  reports:
    cfengine::
      "Loading parameters for context $(context): type = '$(stype)', count = '$(count)', class = '$(class)', state = '$(state)'";
}

body service_method cloud_services_handler
{
      service_bundle => $(cloud_context.stype)("$(sys.ipv4)", "$(this.promiser)", "$(this.service_policy)");
      service_dependence_chain => "start_parent_services";
}

bundle agent ec2(hub, service, state)
{
  classes:
      "parsed_ok" expression => regextract(
                                            "(\d+) (\S+)",
                                            "$(service)",
                                            "params"
                                          );

      "start"   expression => strcmp("start",  "$(state)");
      "stop"    expression => strcmp("stop",   "$(state)");

      "count_determined" expression => isvariable("current_count");

    parsed_ok.count_determined::
      "change_not_needed" expression => strcmp("$(instances)", "$(current_count)");
      "bootstrap_needed" expression => isgreaterthan("$(instances)", "$(current_count)");
      "decom_needed" expression => islessthan("$(instances)", "$(current_count)");

  vars:
    parsed_ok::
      "class" string => "$(params[2])";
      "prefix" string => "$(cloud_context.active_prefix)";

      "ec2_param_names" slist => getindices("$(prefix)ec2");
      "ec2_params" slist => maplist("--ec2 $(this)=$($(prefix)ec2[$(this)])", "ec2_param_names");

      "shim" string => concat("$($(prefix)bundle_home)/scripts/shim.pl ", join(" ", "ec2_params"), " --hub=$(hub) --install_cfengine=$($(prefix)contexts_text[install_cfengine]) ec2");

      "current_count" string => execresult("$(shim) count $(class)", "useshell");

    parsed_ok.start::
      "instances" string => "$(params[1])";
      # catch "stop" and "disable"
    parsed_ok.stop::
      "instances" string => "0";

  commands:
    count_determined.!change_not_needed::
      "$(shim) control $(instances) $(class)";

  reports:

    count_determined::
      "Current count of service '$(service)' = $(current_count)";
    count_determined.cloud_services_verbose::
      "To run a command, e.g. ssh to all machine (but beware, this works best if you have just a few instances): $(shim) run $(class) 'ssh -i YOUR-PRIVATE-SSH-KEY -l ubuntu'";
      "To see the console output of all the machines: $(shim) console $(class)";
      "To list all the machines (just node names or all info, including DNS): $(shim) [list|list-full] $(class)";
    !parsed_ok::
      "Sorry, service '$(service)' could not be parsed to pass to the shim!";
    count_determined.start.change_not_needed::
      "Service '$(service)' does not need to be started by the shim: $(instances) instances of class $(class) already exist";
    count_determined.stop.change_not_needed::
      "Service '$(service)' does not need to be stopped by the shim: we have $(instances) instances of class $(class)";
    count_determined.start.!change_not_needed::
      "Service '$(service)' will be started by the shim: $(instances) instances of class $(class) (current $(current_count))";
    count_determined.stop.!change_not_needed::
      "Service '$(service)' will be stopped by the shim: $(instances) instances (current $(current_count)) of class $(class) ";
    bootstrap_needed::
      "Bootstrapping will be needed";
    decom_needed::
      "Decom will be needed";
    cfengine::
      "EC2 goal: put service '$(service)' in state $(state).";
}

bundle agent vcli(hub, service, state)
{
  classes:
      "parsed_ok" expression => regextract(
                                            "(\d+) (\S+)",
                                            "$(service)",
                                            "params"
                                          );

      "start" expression => strcmp("start", "$(state)");
      "stop"  expression => strcmp("stop",  "$(state)");

      "ssl_noverify" expression => strcmp("$(cloud_context.disable_ssl_verify)", "1");

    parsed_ok::
      "count_determined" expression => regcmp("\d+", "$(current_count)");

    parsed_ok.count_determined::
      "bootstrap_needed"   expression => isgreaterthan("$(instances)", "$(current_count)");
      "decom_needed"       expression => islessthan("$(instances)", "$(current_count)");

  vars:
    !count_determined::
      # for testing, use the Perl or hard-coded counts
      # "current_count" string => execresult("$(VMCMD_COUNT)", "useshell");

      # the following will randomly return a number between 0 and 2
      # "current_count" string => execresult("/usr/bin/perl -e'print int rand 3'", "useshell");

      # hard-code the count for testing
      "current_count" string => "2";

    ssl_noverify::
      "cmd_prefix" string => "/usr/bin/env PERL_LWP_SSL_VERIFY_HOSTNAME=0 ";
    !ssl_noverify::
      "cmd_prefix" string => "";

    parsed_ok::
      "class"  string => "$(params[2])";
      "prefix" string => "$(cloud_context.active_prefix)";

      "master_image" string => "ubuntu-12.04-i386-master";
      "child_prefix" string => "ubuntu-12.04-i386-clone-";

      "grep"  string => "/bin/grep";
      "wc"    string => "/bin/wc";
      "tail"  string => "/bin/tail";
      "vifs"  string => "$(cmd_prefix)/usr/bin/vifs";
      "vmcmd" string => "$(cmd_prefix)/usr/bin/vmware-cmd";
      "vmkfs" string => "$(cmd_prefix)/usr/bin/vmkfstools";

      "u"      string => "$($(prefix)vcli[user])";
      "p"      string => "$($(prefix)vcli[password])";
      "path"   string => "$($(prefix)vcli[fullpath])";
      "ds"     string => "$($(prefix)vcli[datastore])";
      "srv"     string => "$($(prefix)vcli[esxi_server])";

      "VIFS_COPY"       string => "$(vifs) --server $(srv) --username $(u) --password $(p) -c";
      "VIFS_DELETE"     string => "$(vifs) --server $(srv) --username $(u) --password $(p) -r";
      "VIFS_DIR"        string => "$(vifs) --server $(srv) --username $(u) --password $(p) -D";
      "VIFS_GET"        string => "$(vifs) --server $(srv) --username $(u) --password $(p) -get";
      "VIFS_MKDIR"      string => "$(vifs) --server $(srv) --username $(u) --password $(p) -M";
      "VIFS_PUT"        string => "$(vifs) --server $(srv) --username $(u) --password $(p) -put";
      "VMCMD_GETSTATE"  string => "$(vmcmd) -H $(srv) -U $(u) -P $(p) $(path)/$(vm_name)/$(vm_name).vmx getstate";
      "VMCMD_LIST"      string => "$(vmcmd) -H $(srv) -U $(u) -P $(p) -l";
      "VMCMD_COUNT"     string => "$(vmcmd) -H $(srv) -U $(u) -P $(p) -l | $(grep) -v $(master_image) | $(grep) $(child_prefix) | $(wc) -l"; # TODO: find out if this counts properly
      "VMCMD_FIND_LAST" string => "$(vmcmd) -H $(srv) -U $(u) -P $(p) -l | $(grep) -v $(master_image) | $(grep) $(child_prefix) | $(tail) -1"; # TODO: find out if this gives us the last VM correctly
      "VMCMD_REG"       string => "$(vmcmd) -H $(srv) -U $(u) -P $(p) -s register";
      "VMCMD_START"     string => "$(vmcmd) -H $(srv) -U $(u) -P $(p) $(path)/$(vm_name)/$(vm_name).vmx start";
      "VMCMD_STOP"      string => "$(vmcmd) -H $(srv) -U $(u) -P $(p) $(path)/$(vm_name)/$(vm_name).vmx stop soft";
      "VMCMD_UNREG"     string => "$(vmcmd) -H $(srv) -U $(u) -P $(p) -s unregister $(path)/$(vm_name)/$(vm_name).vmx";
      "VMKFSTOOLS"      string => "$(vmkfs) --server $(srv) --username $(u) --password $(p) -i";

    parsed_ok.start::
      "instances" string => "$(params[1])";
      # catch "stop"
    parsed_ok.stop::
      "instances" string => "0";

    bootstrap_needed::
      "instances_needed" string => execresult("/usr/bin/expr $(instances) - $(current_count)", "noshell");
      "next_instance_offset" string => execresult("/usr/bin/expr 1 + $(current_count)", "noshell");
      "next_instance" string => "$(child_prefix)$(next_instance_offset)";

    decom_needed::
      "instances_needed" string => execresult("/usr/bin/expr $(current_count) - $(instances)", "noshell");
      "last_instance" string => execresult("/bin/echo '[[[$(VMCMD_FIND_LAST)]]]'", "noshell");

  methods:
    bootstrap_needed::
      "CLONE"  usebundle => vmware_clone("$(master_image)", "$(next_instance)");
      "START"  usebundle => vmware_start("$(next_instance)");

    decom_needed::
      "STOP"   usebundle => vmware_stop("$(last_instance)");
      "DELETE" usebundle => vmware_delete("$(last_instance)");

  reports:
    verbose.count_determined::
      "Current count of service '$(service)' = $(current_count)";
    !parsed_ok::
      "Sorry, service '$(service)' could not be parsed to pass to the shim!";
    !bootstrap_needed.!decom_needed::
      "Service '$(service)' does not need to be started or stopped: $(instances) instances of class $(class) already exist";
    bootstrap_needed::
      "Service '$(service)' requires bootstrap: requested $(instances) instances of class $(class) (current $(current_count))";
    decom_needed::
      "Service '$(service)' requires decom: requested $(instances) instances of class $(class) (current $(current_count))";
    cfengine::
      "vcli goal: put service '$(service)' in state $(state); parsed into '$(params[1])' and '$(params[2])'.  Currently we have $(current_count) instances.";
    decom_needed::
      "decom is needed";
    verbose::
      "The current_count was obtained from [[[$(VMCMD_COUNT)]]]";
}

# -----------------------------------------------------------------------------

bundle agent vmware_clone(vm_source, vm_clone)
{
  vars:
    any::
      "reg_status" string => execresult("$(vcli.VMCMD_LIST)","noshell");

      #

  classes:
    any::
      "have_source_dir"  expression => returnszero("$(vcli.VIFS_DIR) \"[$(vcli.ds)] $(vm_source)/\" > /dev/null","useshell");
      "have_clone_dir"   expression => returnszero("$(vcli.VIFS_DIR) \"[$(vcli.ds)] $(vm_clone)/\"  > /dev/null","useshell");
      "have_clone_vmx"   expression => fileexists("/tmp/$(vm_clone).vmx");
      "clone_registered" expression => regcmp(".*$(vm_clone).*","$(reg_status)");
      #

  files:
    clean_up::
      "/tmp/$(vm_clone).vmx.*"
      delete => tidy;

    have_clone_vmx.!clone_registered::
      "/tmp/$(vm_clone).vmx"
      edit_line => reconfigurevmx("$(vm_source)","$(vm_clone)"),
      classes => if_repaired("then_upload");

      #

  commands:
    have_source_dir.!have_clone_dir::
      "$(vcli.VIFS_MKDIR) \"[$(vcli.ds)] $(vm_clone)/\"";
      "$(vcli.VMKFSTOOLS) \"[$(vcli.ds)] $(vm_source)/$(vm_source).vmdk\" \"[$(vcli.ds)] $(vm_clone)/$(vm_clone).vmdk\"";
      "$(vcli.VIFS_COPY) \"[$(vcli.ds)] $(vm_source)/$(vm_source).nvram\" \"[$(vcli.ds)] $(vm_clone)/$(vm_clone).nvram\"";

    !have_clone_vmx.!have_clone_dir::
      "$(vcli.VIFS_GET) \"[$(vcli.ds)] $(vm_source)/$(vm_source).vmx\" /tmp/$(vm_clone).vmx";

    then_upload::
      "$(vcli.VIFS_PUT) /tmp/$(vm_clone).vmx \"[$(vcli.ds)] $(vm_clone)/$(vm_clone).vmx\""
      classes => if_repaired("register_vm");

    register_vm.!clone_registered::
      "$(vcli.VMCMD_REG) $(vcli.path)/$(vm_clone)/$(vm_clone).vmx"
      classes => if_repaired("clean_up");
}

#####

bundle edit_line reconfigurevmx(s,c)
{
  delete_lines:
      ".*uuid.*";
      ".*extendedConfigFile.*";
      ".*$(s).*";
      ".*sched.swap.derivedName.*";

  insert_lines:
      "nvram = \"$(c).nvram\"";
      "displayName = \"$(c)\"";
      "scsi0:0.fileName = \"$(c).vmdk\"";
}

# -----------------------------------------------------------------------------

bundle agent vmware_start(vm_name)
{
  vars:
    any::
      "reg_status" string => execresult("$(vcli.VMCMD_LIST)","noshell");
      "vm_status"  string => execresult("$(vcli.VMCMD_GETSTATE)","noshell");

      #

  classes:
    any::
      "vm_registered"   expression => regcmp(".*$(vm_name).*","$(reg_status)");
      "vm_is_off"       expression => regcmp(".*off","$(vm_status)");
      "vm_is_suspended" expression => regcmp(".*suspended","$(vm_status)");

      "no_reg_status"   not => isvariable("reg_status");

      #
  commands:
    vm_registered.(vm_is_off|vm_is_suspended)::
      "$(vcli.VMCMD_START)";
}

# -----------------------------------------------------------------------------

bundle agent vmware_stop(vm_name)
{
  vars:
    any::
      "parameters" slist => getindices("$(inputs)");

      "reg_status" string => execresult("$(vcli.VMCMD_LIST)","noshell");
      "vm_status"  string => execresult("$(vcli.VMCMD_GETSTATE)","noshell");

      #

  classes:
    any::
      "vm_registered"   expression => regcmp(".*$(vm_name).*","$(reg_status)");
      "vm_is_on"        expression => regcmp(".*on","$(vm_status)");

      #

  commands:
    vm_registered.vm_is_on::
      "$(vcli.VMCMD_STOP)";
}

# -----------------------------------------------------------------------------

bundle agent vmware_delete(vm_name)
{
  vars:
    any::
      "parameters" slist => getindices("$(inputs)");

      "reg_status" string => execresult("$(vcli.VMCMD_LIST)","noshell");
      "vm_status"  string => execresult("$(vcli.VMCMD_GETSTATE)","noshell");

      #

  classes:
    any::
      "vm_registered"   expression => regcmp(".*$(vm_name).*","$(reg_status)");
      "vm_is_on"        expression => regcmp(".*on","$(vm_status)");

      #

  commands:
    vm_registered::
      "$(vcli.VMCMD_STOP)";
      "$(vcli.VMCMD_UNREG)";
      "$(vcli.VIFS_DELETE) \"[$(vcli.ds)] $(vm_name)\" -f";
}
