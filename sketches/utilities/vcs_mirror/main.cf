bundle agent vcs_mirror(prefix)
{
  meta:
      "vars[string][vcs]"     string => "PATH";
      "vars[string][path]"    string => "PATH";
      "vars[string][origin]"  string => "URL";
      "vars[string][branch]"  string => "";

      # this is not called "user" so it won't be confused with the remote user
      "vars[string][runas]"   string => "user";
      "vars[string][umask]"   string => "octal";

  defaults:
      # acceptable vcs values: ".*/git" or ".*/svn"
      "vcs"    string => "/unknown/version/control", if_match_regex => "^(?!.*/(git|svn))$";
      "runas"  string => getenv("USER", 128), if_match_regex => "";
      "umask"  string => "077",               if_match_regex => "";

  vars:
      "vcs"                   string => "$($(prefix)vcs)";
      "path"                  string => "$($(prefix)path)";
      "origin"                string => "$($(prefix)origin)";
      "branch"                string => "$($(prefix)branch)";
      "runas"                 string => "$($(prefix)runas)";
      "umask"                 string => "$($(prefix)umask)";
      "canon_prefix" string => canonify("$(prefix)");
      "vcs_type" string => lastnode("$(vcs)","/");

      "git_update_command" slist =>
      {
        # Remove untracked files
        "$(vcs) clean -f -f -x -q -d .",
        # Discard changes to index and working tree since HEAD
        "$(vcs) reset -q --hard HEAD",
        # Check out the proper branch
        "$(vcs) checkout -q $(branch)",
        # Pull the latest changes from origin
        "$(vcs) pull -q -s recursive -Xtheirs origin $(branch)",
        # Reset the working tree to the latest updates
        "$(vcs) reset -q --hard HEAD",
      };

      "git_mirror_command" slist =>
      {
        # clone the given repository with Git
        "$(vcs) clone -b $(branch) $(origin) $(path)"
      };

      "git_configfile" string => "$(path)/.git/config";

      "git_config_template" string => "
[core]
        repositoryformatversion = 0
        filemode = true
        bare = false
        logallrefupdates = true
[remote \"origin\"]
        fetch = +refs/heads/*:refs/remotes/origin/*
        url = $(origin)
[branch \"master\"]
        remote = origin
        merge = refs/heads/master
[branch \"$(branch)\"]
        remote = origin
        merge = refs/heads/$(branch)
",
      comment => "The $(git_configfile) template.",
      handle => "update_vars_git_config_template";

      "svn_update_command" slist =>
      {
        "$(vcs) cleanup",
        "$(vcs) up",
        "$(vcs) revert",
      };

      "svn_mirror_command" slist =>
      {
        # clone the given repository with Subversion
        "$(vcs) co $(origin) $(path)"
      };

      "svn_configfile" string => "$(path)/.svn/entries";

  classes:
      "use_git" expression => strcmp(lastnode("$(vcs)","/"), "git");
      "use_svn" expression => strcmp(lastnode("$(vcs)","/"), "svn");
      "known_vcs" or => { "use_git", "use_svn" };
      "path_exists" expression => fileexists("$(path)");

      # I can't use vcs_configfile here because it doesn't converge soon enough
      "vcsconfig_exists" expression => fileexists("$($(vcs_type)_configfile)"),
      ifvarclass => "known_vcs";

  # files:
  #   use_git::
  #     "$(git_configfile)"
  #     handle => "$(vcs_type)_configfile_contents",
  #     comment => "Expand Git config file from variable",
  #     create => "false",
  #     edit_defaults => empty,
  #     edit_line => insert_lines("$(git_config_template)");

  # commands:

  #   known_vcs.vcsconfig_exists::
  #     "$($(vcs_type)_update_command)"
  #     handle     => "$(vcs_type)_update_with_user_command",
  #     contain    => setuid_umask_in_dir("$(runas)", "$(path)", "$(umask)"),
  #     ifvarclass => "!$(canon_prefix)vcs_mirrored",
  #     comment    => "Update an existing VCS repository in $(path), user override to $(runas)";

  #   known_vcs.!vcsconfig_exists::
  #     "$($(vcs_type)_mirror_command)"
  #     handle     => "$(vcs_type)_mirror_with_user_command",
  #     contain    => setuid_umask_in_dir("$(runas)", "/", "$(umask)"),
  #     ifvarclass => "!$(canon_prefix)vcs_mirrored",
  #     classes    => if_ok("$(canon_prefix)vcs_mirrored"),
  #     comment    => "Clone a VCS repository in $(path), user override to $(runas)";

  reports:
    !known_vcs::
      "Sorry, the requested VCS '$(vcs)' is not handled yet.";

    verbose.known_vcs::
      "Cool, we're using $(vcs_type).  We will look for the config file $($(vcs_type)_configfile)";
      "VCS is $(vcs), to be executed as user $(runas) / umask $(umask), origin $(origin), branch $(branch), target path $(path).";

    verbose.known_vcs.vcsconfig_exists::
      "VCS config file $($(vcs_type)_configfile) exists";

    verbose.known_vcs.!vcsconfig_exists::
      "VCS config file $($(vcs_type)_configfile) does not exist";

    verbose::
      "New clone of $(origin) (branch $(branch) created in $(path)"
      ifvarclass => "$(canon_prefix)vcs_mirrored";

    known_vcs.path_exists.!vcsconfig_exists::
      "Sorry, we could not clone $(origin) (branch $(branch)) in $(path) because that path already exists";
}

bundle agent meta_vcs_mirror
{
  vars:
      # acceptable values: "/usr/bin/git" for example
      "optional_argument[vcs]" string => "string";
      "default[vcs]"           string => "/usr/bin/git";

      "argument[path]"   string => "string";
      "argument[origin]" string => "string";
      "argument[branch]" string => "string";

      # this is not called "user" so it won't be confused with the remote user
      "optional_argument[runas]" string => "string";
      # as far as I know 128 is more than enough on any OS
      "default[runas]"           string => getenv("USER", 128);

      # this changes the umask from the default 077
      "optional_argument[umask]" string => "string";
      "default[umask]"           string => "077";

      # this can't be determined from within the bundle due to:
      # https://cfengine.com/bugtracker/view.php?id=718
      "optional_argument[bundle_home]" string => "string";
      # this default will probably be incorrect, either use cfsketch --generate
      # or supply it yourself
      "default[bundle_home]"           string => dirname("$(this.promise_filename)");
}

body contain setuid_umask_in_dir(user, dir, umask)
{
      chdir => "$(dir)";
      exec_owner => "$(user)";
      umask => "$(umask)";
}

body contain umask_in_dir(dir, umask)
{
      chdir => "$(dir)";
      umask => "$(umask)";
}
