body file control
{
  namespace => "cfdc_vcs_mirror";
}

bundle agent vcs_mirror(prefix, bundle_home, vcs, path, origin, branch, runas, umask, testboolean)
{
  meta:
      # __PREFIX__ will be supplied by cf-sketch
      "vars[prefix][type]"         string => "NON_EMPTY_STRING";
      "vars[prefix][default]"      string => "__PREFIX__";

      # __BUNDLE_HOME__ will be supplied by cf-sketch
      "vars[bundle_home][type]"    string => "NON_EMPTY_STRING";
      "vars[bundle_home][default]" string => "__BUNDLE_HOME__";

      "vars[vcs][type]"            string => "PATH";

      "vars[path][type]"           string => "PATH";

      "vars[origin][type]"         string => "HTTP_URL|PATH";

      "vars[branch][type]"         string => "NON_EMPTY_STRING";
      "vars[branch][default]"      string => "NON_EMPTY_STRING";

      # this is not called "user"  so it won't be confused with the remote user
      "vars[runas][type]"          string => "NON_EMPTY_STRING";
      "vars[runas][default]"       string => getenv("USER", 128);

      "vars[umask][type]"          string => "OCTAL";
      "vars[umask][default]"       string => "022";

      # this is a boolean (e.g. 0 or 1, 'yes' or 'no') stored in a string
      "vars[testboolean][type]"    string => "BOOLEAN";

      # this is a context (e.g. 'any') stored in a string
      "vars[testcontext][type]"    string => "CONTEXT";

  vars:
      "canon_prefix" string => canonify("$(prefix)");
      "vcs_type" string => lastnode("$(vcs)","/");

      "git_update_command" slist =>
      {
        # Remove untracked files
        "$(vcs) clean -f -f -x -q -d .",
        # Discard changes to index and working tree since HEAD
        "$(vcs) reset -q --hard HEAD",
        # Check out the proper branch
        "$(vcs) checkout -q $(branch)",
        # Pull the latest changes from origin
        "$(vcs) pull -q -s recursive -Xtheirs origin $(branch)",
        # Reset the working tree to the latest updates
        "$(vcs) reset -q --hard HEAD",
      };

      "git_mirror_command" slist =>
      {
        # clone the given repository with Git
        "$(vcs) clone -b $(branch) $(origin) $(path)"
      };

      "git_configfile" string => "$(path)/.git/config";

      "git_config_template" string => "
[core]
        repositoryformatversion = 0
        filemode = true
        bare = false
        logallrefupdates = true
[remote \"origin\"]
        fetch = +refs/heads/*:refs/remotes/origin/*
        url = $(origin)
[branch \"master\"]
        remote = origin
        merge = refs/heads/master
[branch \"$(branch)\"]
        remote = origin
        merge = refs/heads/$(branch)
",
      comment => "The $(git_configfile) template.",
      handle => "update_vars_git_config_template";

      "svn_update_command" slist =>
      {
        "$(vcs) cleanup",
        "$(vcs) up",
        "$(vcs) revert",
      };

      "svn_mirror_command" slist =>
      {
        # clone the given repository with Subversion
        "$(vcs) co $(origin) $(path)"
      };

      "svn_configfile" string => "$(path)/.svn/entries";

  classes:
      "use_git" expression => strcmp(lastnode("$(vcs)","/"), "git");
      "use_svn" expression => strcmp(lastnode("$(vcs)","/"), "svn");
      "known_vcs" or => { "use_git", "use_svn" };

      "variables_ok" and => { "known_vcs" };

      "path_exists" expression => fileexists("$(path)");

      # I can't use vcs_configfile here because it doesn't converge soon enough
      "vcsconfig_exists" expression => fileexists("$($(vcs_type)_configfile)"),
      ifvarclass => "known_vcs";

  # files:
  #   variables_ok.use_git::
  #     "$(git_configfile)"
  #     handle => "$(vcs_type)_configfile_contents",
  #     comment => "Expand Git config file from variable",
  #     create => "false",
  #     edit_defaults => empty,
  #     edit_line => insert_lines("$(git_config_template)");

  # commands:

  #   variables_ok.vcsconfig_exists::
  #     "$($(vcs_type)_update_command)"
  #     handle     => "$(vcs_type)_update_with_user_command",
  #     contain    => setuid_umask_in_dir("$(runas)", "$(path)", "$(umask)"),
  #     ifvarclass => "!$(canon_prefix)vcs_mirrored",
  #     comment    => "Update an existing VCS repository in $(path), user override to $(runas)";

  #   variables_ok.!vcsconfig_exists::
  #     "$($(vcs_type)_mirror_command)"
  #     handle     => "$(vcs_type)_mirror_with_user_command",
  #     contain    => setuid_umask_in_dir("$(runas)", "/", "$(umask)"),
  #     ifvarclass => "!$(canon_prefix)vcs_mirrored",
  #     classes    => if_ok("$(canon_prefix)vcs_mirrored"),
  #     comment    => "Clone a VCS repository in $(path), user override to $(runas)";

  reports:
    !known_vcs::
      "Sorry, the requested VCS '$(vcs)' is not handled yet.";

    verbose.variables_ok::
      "Cool, we're using $(vcs_type).  We will look for the config file $($(vcs_type)_configfile)";
      "VCS is $(vcs), to be executed as user $(runas) / umask $(umask), origin $(origin), branch $(branch), target path $(path).";

    verbose.variables_ok.vcsconfig_exists::
      "VCS config file $($(vcs_type)_configfile) exists";

    verbose.variables_ok.!vcsconfig_exists::
      "VCS config file $($(vcs_type)_configfile) does not exist";

    verbose::
      "New clone of $(origin) (branch $(branch) created in $(path)"
      ifvarclass => "$(canon_prefix)vcs_mirrored";

    variables_ok.path_exists.!vcsconfig_exists::
      "Sorry, we could not clone $(origin) (branch $(branch)) in $(path) because that path already exists";
}


body contain setuid_umask_in_dir(user, dir, umask)
{
      chdir => "$(dir)";
      exec_owner => "$(user)";
      umask => "$(umask)";
}

body contain umask_in_dir(dir, umask)
{
      chdir => "$(dir)";
      umask => "$(umask)";
}
