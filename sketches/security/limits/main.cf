body file control
{
      namespace => "cfdc_security_limits";
}

bundle agent security_limits(class_prefix, canon_prefix, filename, domains)
{
  meta:
      "vars[class_prefix][type]"      string => "NON_EMPTY_STRING";
      "vars[class_prefix][default]"   string => "__CLASS_PREFIX__";

      "vars[canon_prefix][type]"      string => "NON_EMPTY_STRING";
      "vars[canon_prefix][default]"   string => "__CANON_PREFIX__";

      "vars[ensure_absent][type]"     string => "CONTEXT";
      "vars[ensure_absent][default]"  string => "!any";

      "vars[empty_first][type]"       string => "CONTEXT";
      "vars[empty_first][default]"    string => "!any";

      "vars[debug][type]"             string => "CONTEXT";
      "vars[debug][default]"          string => "!any";

      "vars[test][type]"              string => "CONTEXT";
      "vars[test][default]"           string => "!any";

      "vars[verbose][type]"           string => "CONTEXT";
      "vars[verbose][default]"        string => "!any";

      "vars[filename][type]"          string => "PATH";
      "vars[filename][default]"       string => "/etc/security/limits.conf";

      "vars[domains][type]"           string => "ARRAY()";

  vars:
      "items" slist => { "core",
                         "data",
                         "fsize",
                         "memlock",
                         "nofile",
                         "rss",
                         "stack",
                         "cpu",
                         "nproc",
                         "as",
                         "maxlogins",
                         "maxsyslogins",
                         "priority",
                         "locks",
                         "sigpending",
                         "msqqueue",
                         "nice",
                         "rtprio",
                         "chroot",
                       };

      "types" slist => { "soft", "hard", "-" };
      "mgmt_policies" slist => { "ensure_present", "ensure_absent" };

      "domain_keys" slist => { getindices("$(domains)") };

    default:test::
      "owner" string => getenv("LOGNAME", 100);
    !default:test::
      "owner" string => "root";

  classes:
      "empty_first" expression => "$(class_prefix)empty_first";
      "ensure_absent" expression => "$(class_prefix)ensure_absent";

      "debug_security_limits" or => { "$(class_prefix)debug" };
    default:debug::
      "debug_security_limits" or => { "any" };

  files:
    !empty_first.!ensure_absent::
      "$(filename)"
      create => "true",
      handle => "security_limits_files_limits_conf_ensure_present",
      edit_line => set_limits_selective($(domains),
                                        @(security_limits.items),
                                        @(security_limits.types),
                                        @(security_limits.domain_keys)),
      perms => default:mog("644", "$(owner)", "$(owner)"),
      classes => default:if_repaired("$(canon_prefix)repaired"),
      comment => "Ensure the specified lines are present, we dont care about other lines";

    empty_first.!ensure_absent::
      "$(filename)"
      create => "true",
      handle => "security_limits_files_limits_conf_empty_first_ensure_present",
      edit_line => set_limits_complete($(domains),
                                       @(security_limits.items),
                                       @(security_limits.types),
                                       @(security_limits.domain_keys)),
      edit_defaults => default:empty,
      perms => default:mog("644", "$(owner)", "$(owner)"),
      classes => default:if_repaired("$(class_prefix)repaired"),
      comment    => "Ensure only the specified lines exist.";

    ensure_absent::
      "$(filename)"
      create => "true",
      handle => "security_limits_files_limits_conf_ensure_absent",
      edit_line => set_limits_removal($(domains),
                                      @(security_limits.items),
                                      @(security_limits.types),
                                      @(security_limits.domain_keys)),
      perms => default:mog("644", "$(owner)", "$(owner)"),
      classes => default:if_repaired("$(class_prefix)repaired"),
      comment    => "Ensure the specified lines do not exist.";

  reports:
    debug_security_limits::
      "Security limits policy in debug mode, managing domains $(domain_keys)";

      "Given: $(domain_keys) $(types) $(items) = $($(domains)[$(domain_keys)][$(types)][$(items)])";

      "I repaired the $(filename) file",
      ifvarclass => "$(canon_prefix)repaired";

    empty_first::
      "Empty First: Enabled";

    ensure_absent::
      "Mgmt Policy: ensure absent";

    !ensure_absent::
      "Mgmt Policy: ensure present";

}

bundle edit_line set_limits_removal(dref, items, types, domains)
{
  vars:
      "myitems" slist => { @(items) };
      "mytypes" slist => { @(types) };
      "mydomains" slist => { @(domains) };

  classes:
      "$(mydomains)_$(mytypes)_$(myitems)_defined" expression => isvariable("$(dref)[$(mydomains)][$(mytypes)][$(myitems)]");

      "debug_security_limits" or => { "default:debug" };

  insert_lines:
      "# This file is managed by CFEngine, manual edits may be reverted";

  delete_lines:
      "^\s*$(mydomains)\s+$(mytypes)\s+$(myitems)\s+.*"
      ifvarclass => canonify("$(mydomains)_$(mytypes)_$(myitems)_defined");

  reports:
    debug_security_limits::
      "Removing line ^\s*$(mydomains)\s+$(mytypes)\s+$(myitems)\s+.*"
      ifvarclass => canonify("$(mydomains)_$(mytypes)_$(myitems)_defined");
}

bundle edit_line set_limits_selective(dref, items, types, domains)
{
  vars:
      "myitems" slist => { @(items) };
      "mytypes" slist => { @(types) };
      "mydomains" slist => { @(domains) };

  classes:
      "$(mydomains)_$(mytypes)_$(myitems)_defined" expression => isvariable("$(dref)[$(mydomains)][$(mytypes)][$(myitems)]");
    default:debug::
      "debug_security_limits" or => { "any" };

  insert_lines:
      "# This file is managed by CFEngine, manual edits may be reverted";
      "$(mydomains) $(mytypes) $(myitems) $($(dref)[$(mydomains)][$(mytypes)][$(myitems)])"
      ifvarclass => and(canonify("$(mydomains)_$(mytypes)_$(myitems)_defined"), canonify("replace_done_$(edit.filename)_$(mydomains)_$(mytypes)_$(myitems)"));

  replace_patterns:
      "^\s*($(mydomains)\s+$(mytypes)\s+$(myitems)\s+(?!$($(dref)[$(mydomains)][$(mytypes)][$(myitems)])$)).*$"
      replace_with => default:value("$(mydomains) $(mytypes) $(myitems) $($(dref)[$(mydomains)][$(mytypes)][$(myitems)])"),
      classes => default:always("replace_done_$(edit.filename)_$(mydomains)_$(mytypes)_$(myitems)"),
      ifvarclass => canonify("$(mydomains)_$(mytypes)_$(myitems)_defined");

    debug_security_limits::
      "Selectively managing line ^\s*$(mydomains)\s+$(mytypes)\s+$(myitems)\s+.*"
      ifvarclass => canonify("$(mydomains)_$(mytypes)_$(myitems)_defined");
}

bundle edit_line set_limits_complete(dref, items, types, domains)
{
  vars:
      "myitems" slist => { @(items) };
      "mytypes" slist => { @(types) };
      "mydomains" slist => { @(domains) };

  classes:
      "$(mydomains)_$(mytypes)_$(myitems)_defined" expression => isvariable("$(dref)[$(mydomains)][$(mytypes)][$(myitems)]");
    default:debug::
      "debug_security_limits" or => { "any" };

  insert_lines:
      "# This file is managed by CFEngine, manual edits may be reverted";
      "$(mydomains) $(mytypes) $(myitems) $($(dref)[$(mydomains)][$(mytypes)][$(myitems)])"
      ifvarclass => canonify("$(mydomains)_$(mytypes)_$(myitems)_defined");

    debug_security_limits::
      "Completely managing line ^\s*$(mydomains)\s+$(mytypes)\s+$(myitems)\s+.*"
      ifvarclass => canonify("$(mydomains)_$(mytypes)_$(myitems)_defined");
}
