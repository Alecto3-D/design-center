bundle agent security_tcpwrappers(prefix){
# prefix_allow[label][daemons] slist => { "" };
# prefix_allow[label][clients] slist => { "" };
# prefix_allow[label][options] slist => { "" };
# prefix_deny[label][daemons] slist => { "" };
# prefix_deny[label][clients] slist => { "" };
# prefix_deny[label][options] slist => { "" };
# prefix_debug string => "yes|true|on"; # be verbose
# prefix_test_filename  string => "/tmp/hosts"; # use fake file (.allow and .deny are automatically appended for testing)
# prefix_mgmt_policy => full_file|entries_present|entries_absent
vars:
  "bundle" string => "security_tcpwrappers";

  # Get lists of allow and deny rules based on the label
  "allow_rules" slist => getindices("$(prefix)allow");
  "deny_rules"  slist => getindices("$(prefix)deny");

  # Join list elements together to build rule daemon part
  "allowed_daemons_$(allow_rules)" string => join(",", "$(prefix)allow[$(allow_rules)][daemons]");
  "denied_daemons_$(deny_rules)"   string => join(",", "$(prefix)deny[$(deny_rules)][daemons]");

  # Join client list together to build rule client part
  # allow_sshd_all
  "allowed_clients_$(allow_rules)" string => join(",", "$(prefix)allow[$(allow_rules)][clients]");
  "denied_clients_$(deny_rules)"   string => join(",", "$(prefix)deny[$(deny_rules)][clients]");

  # Join list elements together to build rule options part
  "allowed_options_$(allow_rules)" string => join(" : ", "$(prefix)allow[$(allow_rules)][options]");
  "denied_options_$(deny_rules)"   string => join(" : ", "$(prefix)deny[$(deny_rules)][options]");


###########################################################################
# Condense this down to 2 promises, and put them in an array so a         #
# list can be grabbed using getvalues.                                    #
###########################################################################

  # Build allow rules that have optional parts
  "allow_rule[$(allow_rules)]" 
    string => "$(allowed_daemons_$(allow_rules)) : $(allowed_clients_$(allow_rules)) : $(allowed_options_$(allow_rules))",
    policy => "free",
    ifvarclass => "allow_$(allow_rules)_has_options";

  # Build allow rules without optional parts
  "allow_rule[$(allow_rules)]" 
    string => "$(allowed_daemons_$(allow_rules)) : $(allowed_clients_$(allow_rules))",
    policy => "free",
    ifvarclass => "!allow_$(allow_rules)_has_options";

  # Build deny rules that have optional parts
  "deny_rule[$(deny_rules)]" 
    string => "$(denied_daemons_$(deny_rules)) : $(denied_clients_$(deny_rules)) : $(denied_options_$(deny_rules))",
    policy => "free",
    ifvarclass => "deny_$(deny_rules)_has_options";

  # Build allow rules without optional parts
  "deny_rule[$(deny_rules)]" 
    string => "$(denied_daemons_$(deny_rules)) : $(denied_clients_$(deny_rules))",
    policy => "free",
    ifvarclass => "!deny_$(deny_rules)_has_options";

  # Build list of allow and deny rules from arrays. 
  # The lists are needed for full file management.
  # This must be done on the second var pass since classes are needed
  # to build the arrays we are getting values from.
  first_class_pass::
  "allow_rule_list" slist => getvalues("allow_rule");
  "deny_rule_list"  slist => getvalues("deny_rule");

  # Choose files to operate on based on test parameter
  test_security_tcpwrappers::
    "allow_filename"
      string => "$($(prefix)test_filename).allow",
      policy => "free";

    "deny_filename"
      string => "$($(prefix)test_filename).deny",
      policy => "free";

  !test_security_tcpwrappers::
    "allow_filename"
      string => "/etc/hosts.allow",
      policy => "free";

    "deny_filename"
      string => "/etc/hosts.deny",
      policy => "free";

classes:
  "debug_security_tcpwrappers" expression => regcmp("(?i)yes|true|on", "$($(prefix)debug)");
  "test_security_tcpwrappers"  expression => isvariable("$(prefix)test_filename");

  # Decide how we will edit the files
  "mgmt_policy_full_file"  expression => regcmp("(?i)only|complete|full|whole", "$($(prefix)mgmt_policy)");
  "mgmt_policy_entries_present"   expression => regcmp("(?i)present|exists|partial|defined|selective|exist", "$($(prefix)mgmt_policy)");
  "mgmt_policy_entries_absent"     expression => regcmp("(?i)absent|delete|remove|removal|clear", "$($(prefix)mgmt_policy)");
  # Default to least destructive management policy
  "mgmt_policy_entries_present" and => { "!mgmt_policy_entries_absent", "!mgmt_policy_full_file" };

  "allow_$(allow_rules)_has_options" expression => isvariable("$(prefix)allow[$(allow_rules)][options]");
  "deny_$(deny_rules)_has_options"   expression => isvariable("$(prefix)deny[$(deny_rules)][options]");

  # We need to know if we are on the second pass
  "second_class_pass" and => {"first_class_pass"};
  "first_class_pass" and => {"any"};

files:
  # This file edit must be done after the second pass of
  # vars for the access rule to have fully converged

  # If we are completely managing the file we should empty it first
  # This is the reccomended method of management
  second_class_pass.mgmt_policy_full_file::
    "$(allow_filename)"
      handle => "$(bundle)_files_allow_complete",
      create => "true",
      perms => mog("644", "root", "root"),
      classes => if_repaired("$(bundle)_repaired_allow"),
      edit_defaults => empty,
      edit_line => append_if_no_lines("@(security_tcpwrappers.allow_rule_list)"),
      comment => "Completely managed hosts.allow leaves less room for
                  unexpected behavior from stray admins.";

    "$(deny_filename)"
      handle => "$(bundle)_files_deny_complete",
      create => "true",
      perms => mog("644", "root", "root"),
      classes => if_repaired("$(bundle)_repaired_deny"),
      edit_defaults => empty,
      edit_line => append_if_no_lines("@(security_tcpwrappers.deny_rule_list)");

  # If we are only partially mangaging the file we can only promise
  # about the defined rules
  second_class_pass.mgmt_policy_entries_present::
    "$(allow_filename)"
      handle => "$(bundle)_files_allow_partial",
      create => "true",
      perms => mog("644", "root", "root"),
      classes => if_repaired("$(bundle)_repaired_allow"),
      edit_line => append_if_no_lines("@(security_tcpwrappers.allow_rule_list)");

    "$(deny_filename)"
      handle => "$(bundle)_files_deny_partial",
      create => "true",
      perms => mog("644", "root", "root"),
      classes => if_repaired("$(bundle)_repaired_deny"),
      edit_line => append_if_no_lines("@(security_tcpwrappers.deny_rule_list)");

  # If we are managing removal we only ensure specific rules do not exist
  second_class_pass.mgmt_policy_entries_absent::
    "$(allow_filename)"
      handle => "$(bundle)_files_allow_remove",
      create => "true",
      perms => mog("644", "root", "root"),
      classes => if_repaired("$(bundle)_repaired_allow"),
      edit_line => delete_lines_matching("^$(allow_rule_$(allow_rules))$");

    "$(deny_filename)"
      handle => "$(bundle)_files_deny_remove",
      create => "true",
      perms => mog("644", "root", "root"),
      classes => if_repaired("$(bundle)_repaired_deny"),
      edit_line => delete_lines_matching("^$(deny_rule_$(deny_rules))$");


reports:
  second_class_pass::
    # Report when files have been repaired
    "I repaired $(allow_filename)",
      ifvarclass => "$(bundle)_repaired_allow";

    "I repaired $(deny_filename)",
      ifvarclass => "$(bundle)_repaired_deny";

  debug_security_tcpwrappers.second_class_pass::
    # Allow and Deny Rules

    # Report File management policy
    "$(allow_filename) content is fully managed",
      ifvarclass => "mgmt_policy_full_file";

    "$(allow_filename) makes promises about specific rules being present because its partially managed",
      ifvarclass => "mgmt_policy_entries_present";

    "$(allow_filename) makes promises about specific rules being absent because its removal managed",
      ifvarclass => "mgmt_policy_entries_absent";

    "$(deny_filename) content is fully managed",
      ifvarclass => "mgmt_policy_full_file";

    "$(deny_filename) makes promises about specific rules being present because its partially managed",
      ifvarclass => "mgmt_policy_entries_present";

    "$(deny_filename) makes promises about specific rules being absent because its removal managed",
      ifvarclass => "mgmt_policy_entries_absent";


    # Report individual rules
    "ALLOW RULE for $(allow_rules) | $(allow_rule[$(allow_rules)])";

    "DENY RULE for $(deny_rules) | $(deny_rule[$(deny_rules)])";
}

bundle agent meta_security_tcpwrappers{
vars:
# "prefix_allow[label][daemons]" slist => { "" };
# "prefix_allow[label][clients]" slist => { "" };
# "prefix_allow[label][options]" slist => { "" };
# "prefix_deny[label][daemons]" slist => { "" };
# "prefix_deny[label][clients]" slist => { "" };
# "prefix_deny[label][options]" slist => { "" };

  "argument[allow]" string => "array";
  "argument[deny]" string => "array";

  "optional_argument[debug]" string => "context";
  "optional_argument[test_filename]"  string => "string";
  "optional_argument[mgmt_policy]" string => "string";

  "default[mgmt_policy]" string => "entries_present";
}
