# N.B. namespacing this sketch breaks the $(sources) iteration
# N.B. making the type a slist breaks the types iteration

# Used for enforcing the contents of /etc/apt/sources.list or
# /etc/apt/sources.list.d/*.list

bundle agent aptrepos(class_prefix, repos, apt_file, apt_dir)
{
  meta:
      "vars[class_prefix][type]"     string => "NON_EMPTY_STRING";
      "vars[class_prefix][default]"  string => "__CLASS_PREFIX__";

      "vars[repos][type]"            string => "KVARRAY(
_key:NON_EMPTY_STRING
section:NON_EMPTY_STRING:required
file:NON_EMPTY_STRING:required
repo_url:HTTP_URL|FTP_URL:required
distrib:NON_EMPTY_STRING:required
version_distrib:NON_EMPTY_STRING:required
type:STRING:required
)";

      "vars[wipe][type]"             string => "CONTEXT",
      comment => "If true, existing lines will be removed";
      "vars[wipe][default]"          string => "!any";

      "vars[use_apt_file][type]"      string => "CONTEXT",
      comment => "If true, all the configuration will be in $(apt_file)";
      "vars[use_apt_file][default]"   string => "!any";

      "vars[apt_file][type]"         string => "PATH";
      "vars[apt_file][default]"      string => "/etc/apt/sources.list";

      "vars[apt_dir][type]"          string => "PATH";
      "vars[apt_dir][default]"       string => "/etc/apt/sources.list.d";

  vars:
      "sources" slist => getindices("$(repos)"),
      comment => "The repo list for APT";

      "CFEnotice"
      string  => "# This file is managed by CFEngine, manual edits will be reverted",
      comment => "It's nice to let people know why the file keep magically reverting on them";

      "wipe_bool" string => "true",
      ifvarclass => "$(class_prefix)wipe";

      "wipe_bool" string => "false",
      ifvarclass => "!$(class_prefix)wipe";

  methods:
      "write" usebundle => aptrepos_write
      (
        $(class_prefix),
        "$(apt_dir)/$($(repos)[$(sources)][file])",
        "$($(repos)[$(sources)][type])", # a space-separated list!
        "$($(repos)[$(sources)][repo_url])",
        "$($(repos)[$(sources)][distrib])",
        "$($(repos)[$(sources)][version_distrib])",
        "$($(repos)[$(sources)][section])",
        $(wipe_bool),
        $(CFEnotice)
      );

  reports:
    verbose::
      "Source $(sources) (type $($(repos)[$(sources)][type])) is active";
    debug::
      "We looked in the indices of $(repos) to get $(sources)";

}

bundle edit_line aptrepos_prepend_if_no_line(string)
{
  insert_lines:
      "$(string)"
      location => start,
      comment => "Prepend a line to the file if it doesn't already exist";
}

body edit_defaults aptrepos_empty_if_ask(bool)
{
      edit_backup => "false";
      max_file_size => "300000";
      empty_file_before_editing => "$(bool)";
}

bundle agent aptrepos_write(class_prefix, maybe_file, joined_type, url, distrib, version, section, wipe_bool, notice)
{
  vars:
      "types" slist => splitstring("$(joined_type)", " ", "1000");
      "e" slist => maplist("$(this) $(url)/$(distrib)/ $(version) $(section)", "types");

      "file"
      string  => $(apt_file),
      ifvarclass => "$(class_prefix)use_apt_file";

      "file"
      string  => $(maybe_file),
      ifvarclass => "!$(class_prefix)use_apt_file";

  files:
      "$(file)"
      create        => "true",
      handle        => "prepfile_$(file)",
      edit_defaults => aptrepos_empty_if_ask($(wipe_bool)),
      edit_line     => aptrepos_prepend_if_no_line($(notice)),
      comment       => "Create $(file) and note that the file is managed by CFEngine";

      # note that we need to edit the file AFTER it's been possibly
      # created with a notice
      "$(file)"
      edit_defaults =>  std_defs,
      edit_line     =>  append_if_no_line($(e)),
      depends_on    => { "prepfile_$(file)" },
      comment       =>  "Complete or fix $(file).";

  reports:
    debug::
      "Writing $(file): $(e)";
}
