bundle agent local_user_management_add_users_fileedit (users) {
# Expects to be passed a two-dimensional array keyed on username and field
# The following fields are required.
# gecos, uid, gid, home, shell, passwdhash
# Dependancies: replace_or_add from copbl svn 105 or greater, perl
# Example Usage:
#   vars:
#       "users[testuser][gecos]"          string => "My Test User";
#       "users[testuser][uid]"            string => "1500";
#       "users[testuser][gid]"            string => "1500";
#       "users[testuser][home]"           string => "/home/testuser";
#       "users[testuser][shell]"          string => "/bin/bash";
#       "users[testuser][passwdhash]"     string => "$1$cCMJbSmS$/tQtxSsLZmYq3/zp1Vm/l0";
#       # Optional settings
#       "users[testuser][groupname]       string => "mygroupname";
#       "users[testuser][_allow_dup_gid] string => "anythinggoeshere";
#       If groupname is set a named group will be created with the specified gid
#       by default we wont create a named group with a non_unique gid, setting _allow_dup_gid
#       enables this behavior.
# Note:
# This bundle does not handle creating groups, if you assign a gid of a non-existant group
# you should still be able to log in, there is just no named group associated with the gid,
# if you want a named group you should promise that seperately.


    vars:
        linux::
            "skel"                      string => "/etc/skel/";
            "pwfile"                    string => "/etc/passwd";
            "shadowfile"                string => "/etc/shadow";
            "groupfile"                 string => "/etc/group";
            "userlist"                  slist  => getindices("$(users)");
            "pwentry[$(userlist)]"      string => "$(userlist):x:$($(users)[$(userlist)][uid]):$($(users)[$(userlist)][gid]):$($(users)[$(userlist)][gecos]):$($(users)[$(userlist)][home]):$($(users)[$(userlist)][shell])";
            "groupentry[$(userlist)]"   string => "$($(users)[$(userlist)][groupname]):x:$($(users)[$(userlist)][gid]):";

            "days_since_epoch"
                string => execresult("/usr/bin/perl -le 'print int time/(60*60*24)'", "noshell"),
                ifvarclass => "local_user_management_add_users_fileedit_add_$(userlist)",
                comment     => "Only calculate if we need to add a user, otherwise its just wasteful";

            "shadowentry[$(userlist)]"
                string => "$(userlist):$($(users)[$(userlist)][passwdhash]):$(days_since_epoch):0:99999:7:::",
                ifvarclass => "local_user_management_add_users_fileedit_add_$(userlist)",
                comment    => "Only construct the shadow entry for a user if we need to add the user";

    classes:
    ###########################################################################
    #                       Check valid user definition                       #
    ###########################################################################

        "gecos_defined_$(userlist)"
            expression => isvariable("$(users)[$(userlist)][gecos]"),
            comment    => "I consider gecos a required field, check if its defined";

        "uid_defined_$(userlist)"
            expression => isvariable("$(users)[$(userlist)][uid]"),
            comment    => "Since I don't yet do automatic next uid selection
                           uid is a required field, check if its defined";

        "gid_defined_$(userlist)"
            expression => isvariable("$(users)[$(userlist)][gid]"),
            comment    => "Since I dont yet do automatic next gid selection
                           gid is a required field, check if its defined";

        "shell_defined_$(userlist)"
            expression => isvariable("$(users)[$(userlist)][shell]"),
            comment    => "I really think its a good idea to set the shell
                           to something, check if its defined";

        "home_defined_$(userlist)"
            expression => isvariable("$(users)[$(userlist)][home]"),
            comment => "Users really should have a home directoy defined,
                        check if it is defined";

        "passwdhash_defined_$(userlist)"
            expression => isvariable("$(users)[$(userlist)][passwdhash]"),
            comment    => "Without a password set the user wont be able to log in,
                           this is easily debateable to not be a required field";

        "groupname_defined_$(userlist)"
            expression => isvariable("$(users)[$(userlist)][groupname]"),
            comment    => "This is optional, if the groupname is defined
                           we will create a named group with the defined gid.
                           Non-unique gid is allowed with the use of the
                           _allow_dup_gid_defined flag";

        "allow_non_unique_gid_$(userlist)"
            expression => isvariable("$(users)[$(userlist)][_allow_dup_gid]"),
            comment    => "This is optional, the value does not matter
                           if its defined at all we allow the creation of
                           a named group with a duplicate uid";

        "required_elements_defined_$(userlist)"
            and => { "gecos_defined_$(userlist)",
                   },
            comment => "These are required to create a user";

        ###########################################################################
        #                        Determine actions to take                        #
        ###########################################################################

        "local_user_management_add_users_fileedit_add_$(userlist)"
            not        => userexists("$(userlist)"),
            ifvarclass => "required_elements_defined_$(userlist)",
            comment    => "Trigger a class so we know we need to create the user if it does not exist";

        
        "local_user_management_add_users_fileedit_add_$($(users)[$(userlist)][groupname])",
            not     => groupexists("$($(users)[$(userlist)][groupname])"),
            ifvarclass => "groupname_defined_$(userlist)",
            comment => "Trigger a class so we know we should see about creating a user";

        # define a class for the specified user and gid that are in use
        "gid_in_use_$(userlist)_$($(users)[$(userlist)][gid])"
            expression => regline(".*\:.*\:$($(users)[$(userlist)][gid])\:.*$", "/etc/group"),
            #ifvarclass => "allow_non_unique_gid_$(userlist)|groupname_defined_$(userlist)",
            ifvarclass => "groupname_defined_$(userlist)",
            comment => "If we are going to add a named group, we should see if the gid
                        is already in use";

        # define a negative class for convienance
        "gid_not_in_use_$(userlist)_$($(users)[$(userlist)][gid])"
            not => "gid_in_use_$(userlist)_$($(users)[$(userlist)][gid])";

        # define a class signifying settings to create a named group and allowd gid conflicts
        "create_group_and_allow_non_unique_$(userlist)"
            and     => {"groupname_defined_$(userlist)", "allow_non_unique_gid_$(userlist)"},
            comment => "Crete a class when we would like to create a user,
                        and when we dont care about having unique gids";

        # define a class signifying settings to create a named group but not if there is already 
        # a named group with the specified gid
        "create_group_and_not_conflicting_gid_$(userlist)"
            and => {"groupname_defined_$(userlist)", "!gid_in_use_$(userlist)_$($(users)[$(userlist)][gid])"};

        # define a class so that we know for which user we should create groups
        # We only want to do it if there is a named group defined and there are no conflicts
        # or if a named group is defined and we are forcing the named group creation
        "attempt_group_creation_$(userlist)"
            or => {"create_group_and_allow_non_unique_$(userlist)", "create_group_and_not_conflicting_gid_$(userlist)"};

    files:
        linux::
            # Im using replace or add here, but append_if_no_line would also be appropriate
            # I am using replace or add here because I am considering either extending this
            # or creating new bundle that enforces the settings perhaps _enforce_usersettings 
            "$(pwfile)"
                edit_line  => replace_or_add("$(userlist):.*", "$(pwentry[$(userlist)])"),
                ifvarclass => "local_user_management_add_users_fileedit_add_$(userlist)",
                comment   => "Ensure user exists";

            # append_if_no_line is not sufficent here in the event another user entry was in
            # the file, we only want a single shadow entry for a user or unexpected things could
            # happen
            # should passwdhash be a required field? perhaps only set the shadow entry if 
            # passwdhash is defined?
            "$(shadowfile)"
                edit_line  => replace_or_add("$(userlist):.*", "$(shadowentry[$(userlist)])"),
                ifvarclass => "local_user_management_add_users_fileedit_add_$(userlist)",
                comment    => "Ensure user has password entry";

            # Create the users home directory and seed it with the typical files
            "$($(users)[$(userlist)][home])/."
                create      => "true",
                perms       => mog("755", "$($(users)[$(userlist)][uid])", "$($(users)[$(userlist)][gid])"),
                classes     => if_repaired("local_user_management_add_users_fileedit_seed_$(userlist)"),
                ifvarclass => "local_user_management_add_users_fileedit_add_$(userlist)",
                comment     => "Make sure users home directory exists";

            # If we created the users home directy seed it from the typical skel location
            # should we provide a _skel override for the default /etc/skel ?
            # Should we provide a _noseed option ?
            "$($(users)[$(userlist)][home])/."
                depth_search    => recurse("inf"),
                copy_from       => seed_cp("$(local_user_management_add_users_fileedit.skel)"),
                perms           => og("$($(users)[$(userlist)][uid])", "$($(users)[$(userlist)][gid])"),
                ifvarclass      => "local_user_management_add_users_fileedit_seed_$(userlist)",
                comment         => "Seed home directory with skel, but only when we create the home
                                    directory the user should have the choice to remove the seeded files";

            # We only want to create the named group if groupname defined and allow non unique or
            # if groupname defined and there is no gid conflict
            "/etc/group"
                create    => "true",
                edit_line => append_if_no_line("$(groupentry[$(userlist)])"),
                ifvarclass => "attempt_group_creation_$(userlist)";

    reports:
    cfengine::
    "$(userlist)";
    "$(userlist) does not exist, needs created",
        ifvarclass => "local_user_management_add_users_fileedit_add_$(userlist)";

    "groupname_defined",
        ifvarclass => "groupname_defined_$(userlist)";

    "allow_non_unique_gid",
        ifvarclass => "allow_non_unique_gid_$(userlist)";

    "gid in use",
        ifvarclass => "gid_in_use_$(userlist)_$($(users)[$(userlist)][gid])";

    "gid not in use",
        ifvarclass => "gid_not_in_use_$(userlist)_$($(users)[$(userlist)][gid])";

    "create group and allow non unique for $(userlist)",
        ifvarclass => "create_group_and_allow_non_unique_$(userlist)";

#    "gecos OK",
#        ifvarclass => "gecos_defined_$(userlist)";
#    "uid OK",
#        ifvarclass => "uid_defined_$(userlist)";
#    "gid OK",
#        ifvarclass => "gid_defined_$(userlist)";
#    "home OK",
#        ifvarclass => "home_defined_$(userlist)";
#    "shell OK",
#        ifvarclass => "shell_defined_$(userlist)";
#    "passwdhash OK",
#        ifvarclass => "passwdhash_defined_$(userlist)";
#
#    "groupname defined",
#        ifvarclass => "groupname_defined_$(userlist)";
#
#    "gid IN USE",
#        ifvarclass => "gid_in_use_$(userlist)_$(gid)";
#
#    "Non unique allowed and groupname defined",
#        ifvarclass => "allow_non_unique_gid_$(userlist).groupname_defined_$(userlist)";
#
#    "ALL REQUIRED ELEMENTS DEFINED FOR $(userlist)",
#        ifvarclass => "required_elements_defined_$(userlist)";


#        gecos_defined::
#            "gecos is defined";
#        groupname_defined::
#            "groupname_defined";
}
